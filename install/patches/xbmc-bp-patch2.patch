--- C:/Users/Familie/Desktop/Original/Neues Textdokument.txt	Tue Jan 06 16:12:33 2015
+++ C:/Users/Familie/Desktop/Original/MouseStat.cpp	Tue Jan 06 16:10:03 2015
@@ -18,14 +18,18 @@
  *
  */
 
 #include "MouseStat.h"
 #include "guilib/Key.h"
+#include "guilib/GraphicContext.h"
+#include "guilib/GUIWindowManager.h"
 #include "settings/lib/Setting.h"
 #include "utils/TimeUtils.h"
 #include "windowing/WindowingFactory.h"
 
+extern uint32_t click_confines;
+
 CMouseStat::CMouseStat()
 {
   m_pointerState = MOUSE_STATE_NORMAL;
   SetEnabled();
   m_speedX = m_speedY = 0;
@@ -54,30 +58,39 @@
   SetResolution(720, 576, 1, 1);
 }
 
 void CMouseStat::HandleEvent(XBMC_Event& newEvent)
 {
+  int dx = 0;
+  int dy = 0;
+  int ignore_action = 0;
+
+  /* [Touch screens fix] Ignore actions if the pointer is outside of the screen area */
+  if(newEvent.motion.x > g_graphicsContext.GetWidth() || 
+      newEvent.motion.y > g_graphicsContext.GetHeight())
+  {
+    //CLog::Log(LOGWARNING, "[AI] step 1: m_mouseState(%d,%d) newEvnt.motion(%d,%d)\n",
+    //  m_mouseState.x, m_mouseState.y, newEvent.motion.x, newEvent.motion.y
+    //);
+    //printf("[AI] step 1: m_mouseState(%d,%d) newEvnt.motion(%d,%d)\n",
+    //  m_mouseState.x, m_mouseState.y, newEvent.motion.x, newEvent.motion.y
+    //);
+    ignore_action = 1;
+    newEvent.button.button = XBMC_BUTTON_LEFT;
+    newEvent.button.type = XBMC_MOUSEBUTTONDOWN;
+  }
+  
   // Save the mouse position and the size of the last move
-  int dx, dy;
-  if (newEvent.type == XBMC_MOUSEMOTION)
+  else
   {
     dx = newEvent.motion.x - m_mouseState.x;
+	m_mouseState.dx = dx;
+    m_mouseState.x  = m_mouseState.x + dx;
     dy = newEvent.motion.y - m_mouseState.y;
+	m_mouseState.dy = dy;
+    m_mouseState.y  = m_mouseState.y + dy;
   }
-  else if (newEvent.type == XBMC_MOUSEBUTTONDOWN || newEvent.type == XBMC_MOUSEBUTTONUP)
-  {
-    dx = newEvent.button.x - m_mouseState.x;
-    dy = newEvent.button.y - m_mouseState.y;
-  }
-  else
-  {
-    return;
-  }
-  m_mouseState.dx = dx;
-  m_mouseState.dy = dy;
-  m_mouseState.x  = std::max(0, std::min(m_maxX, m_mouseState.x + dx));
-  m_mouseState.y  = std::max(0, std::min(m_maxY, m_mouseState.y + dy));
 
   // Fill in the public members
   if (newEvent.button.type == XBMC_MOUSEBUTTONDOWN)
   {
     if (newEvent.button.button == XBMC_BUTTON_LEFT) m_mouseState.button[MOUSE_LEFT_BUTTON] = true;
@@ -110,11 +123,28 @@
     bDoubleClick[i] = false;
     bHold[i] = 0;
 
     // CButtonState::Update does the hard work of checking the button state
     // and spotting drags, doubleclicks etc
-    CButtonState::BUTTON_ACTION action = m_buttonState[i].Update(now, m_mouseState.x, m_mouseState.y, m_mouseState.button[i]);
+    CButtonState::BUTTON_ACTION action = CButtonState::MB_NONE;
+	
+    if(!ignore_action)
+    {
+      action = m_buttonState[i].Update(now, m_mouseState.x, m_mouseState.y, m_mouseState.button[i]);
+	  }
+	  
+    /* Store raw action */
+    if(i == 0)
+    {
+      m_RawAction = (uint32_t)action;
+    }
+
+    //CLog::Log(LOGWARNING, "[AI]: |   (%d)dx,dy:(%d,%d),newEvent.motion:(%d,%d)\n",
+    //  i, dx, dy, newEvent.motion.x, newEvent.motion.y);
+    //CLog::Log(LOGWARNING, "[AI]: |   (%d)m_mouseState(%d,%d),m_mouseState.button[i]:%d,action:%d",
+    //  i, m_mouseState.x, m_mouseState.y, m_mouseState.button[i], action);
+
     switch (action)
     {
     case CButtonState::MB_SHORT_CLICK:
     case CButtonState::MB_LONG_CLICK:
       bClick[i] = true;
@@ -220,10 +250,15 @@
 }
 
 bool CMouseStat::MovedPastThreshold() const
 {
   return (m_mouseState.dx * m_mouseState.dx + m_mouseState.dy * m_mouseState.dy >= MOUSE_MINIMUM_MOVEMENT * MOUSE_MINIMUM_MOVEMENT);
+}
+
+uint32_t CMouseStat::GetRawAction() const
+{
+  return m_RawAction;
 }
 
 uint32_t CMouseStat::GetAction() const
 {
   return m_Action;
